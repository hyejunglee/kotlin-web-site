---

유형 : 문서

레이아웃 : 참조

카테고리 : "구문"

제목 : "기본 유형"

---

 

# 기본 유형

 

코틀린에서는  모든것이 오브젝트의 의미이고,  당신은 어느 변수에서건 멤버 함수와 속성을 호출 할 수 있습니다 . 구현이 최적화되어 있기 때문에 일부 유형에 내장되어 있지만, 사용자들은 보통 클래스처럼 생각하면 됩니다. 이 섹션에서 우리는 숫자, 문자, 부울 및 배열 등의 유형을 설명합니다.

 

숫자.

 

코틀린 자바와 비슷한 방식으로 숫자를 처리하지만, 정확히 같지는 않습니다. 예를 들어, 숫자들에 대한 함축적인 확대 변환은없고, 리터럴은 경우에 따라 약간 다릅니다.

 

코틀린은 숫자를 나타내는데 다음과 같은 기본 유형을 제공합니다 (자바에 가까운):

 


| Type	 | Bitwidth |
|--------|----------|
| Double | 64       |
| Float	 | 32       |
| Long	 | 64       |
| Int	   | 32       |
| Short	 | 16       |
| Byte	 | 8        |
 

위 표의 형식들은 코틀린에서는 숫자들이 아닙니다. 자바와는 다르게 모두 대문자를 씁니다.

 

### 리터럴 상수

 

리터럴 상수의 구성요소에는 다음과 같은 종류가 있습니다.

 

* 소수 :`123`

* Long형의 문자 끝에 `L` 을 붙이면 됩니다. : `123L`

* 16진법 :  `0x0F`

* 바이너리 :    `0b00001011`

 

참고 : 8진법 리터럴은 지원되지 않습니다.

 

코틀린는 부동 소수점 숫자에 대한 기존의 표기법을 지원합니다 :

 

* 기본적인 Double 형 :`123.5`,`123.5e10`

* Float형의  문자 끝에 `f` 또는 F` 를 붙이면 됩니다.  : `123.5f`

 

### 표현

 

우리가 nullable 숫자나, 제너릭을 포함시키지 않는다면 , 자바 플랫폼에서는 실제로 숫자들이 JVM 기본형식으로 저장됩니다.

후자의 경우 숫자들을 기본type 을 객체로 썼다.

 

기본type의 숫자들은 동일하게 유지되지 않습니다.

 

```kotlin

val a: Int = 10000

print (a === a) // print `true` 값을 비교할 때 '=='과 '==='으로 비교할 수 있습니다.

val boxedA: Int? = a val anotherBoxedA: Int? = a

print (boxedA === anotherBoxedA) // !!! print `false` !!!

print(boxedA === anotherBoxedA) //! prints `false` !!!!

```

 

다른 한편으로는 같게 유지된다.

 

```kotiln

val a: Int  =  10000

print ( a == a ) // prints `true`

val boxedA: Int? =a

val anotherBoxedA: Int? = a

print(boxedA == anotherBoxedA) // prints `true`

```

 

### 명시적 형 변환

 

다른 표현 때문에 , 작은 유형은 더 큰것의 하위유형이 아닙니다.  - [Due to different representations, smaller types are not subtypes of bigger ones.]

 

그렇게 분류하게  된다면 문제가 생길지도 모릅니다.

 

```kotilin

// 실제로 컴파일 되지않는 가상의 코드 입니다.

val a Int = 1 // A boxed Int ( java.lang.Integer)

val b: Long?=a  //Long 형으로 암시적 변환이 되는 부분 (java.lang.Long)

print ( a == b ) // 놀랍지 않나요?  이 표현은 Long 의 equals()메서드가 형이 다른지를 검사하고 확인하여 "false "를 출력합니다.

```

 

So not only identity, but even equality would have been lost silently all over the place.
//그래서 정체성 뿐만 아니라 동일성까지도 모든 부분에서 조용히 사라질 수 있습니다.

 

결론적으로, 작은 타입들은 암시적으로는 큰 타입으로 변환될 수 없습니다.

이것은 우리가 명시적으로 형변환하지 않고 'Int` 변수로  Byte`'형식의 값을 할당 할 수 있다는 것을 의미합니다.

 

```kotlin

val b: Byte = 1  // OK, 리터럴은 정적으로 체크됩니다.

val i: Int = b  // ERROR

```

 

우리는 숫자를 확대하기 위해 명시적 형 변환을 사용할 수 있습니다.

 

```kotiln
val i: Int = b.toInt() // OK : 명시적인 확대

```

 

코틀린에서는 형 변환을 위해서 다음의 타입을 제공합니다.

 

*`toByte () : Byte`   : Byte로 변환

*`toShort () : Short`   : Short 로 변환

*`toInt () : Int`   : Int 로 변환

*`toLong () : Long`   : Long 으로 변환

*`toFloat () : Float`   : Float 로 변환

*`toDouble () : Double`   : Double 로 변환

*`toChar () : Char`   : Char로 변환

 

암시적 형 변환의 없는것는  왜냐하면 형식은 문맥에서 유추 되고, 적절한 연산을 위해 산술 연산이 오버로드 되기때문에 암시적 형변환이 없는 경우는 드뭅니다. 다음 예시를 보세요.

 

```kotlin
val l = 1L + 3 // Long + Int => Long

```

 

### 연산

 

Kotlin은 적절한 클래스의 멤버로 선언 된 숫자에 대한 산술 연산의 표준 집합을 지원합니다 (그러나 컴파일러는 호출을 해당 지침으로 최적화합니다).

연산자 오버로딩 (operator overloading.html)를 참조하십시오.

 

비트 연산으로, 특정한 문자는 없지만 중위 형태로 호출 할 수있는 메서드를 제공합니다. 예시는 다음과 같습니다.

 

```kotlin
val x = (1 shl 2) and 0x000FF000

```

 

비트 연산의 전체 목록은 다음과 같습니다 (`Int`와`Long`에만 사용 가능) 

 

* `shl(bits)` – signed shift left (Java's `<<`)

* `shr(bits)` – signed shift right (Java's `>>`)

* `ushr(bits)` – unsigned shift right (Java's `>>>`)

* `and(bits)` – bitwise and

* `or(bits)` – bitwise or

* `xor(bits)` – bitwise xor

* `inv()` – bitwise inversion

 

등장 인물

 

문자는 유형 'Char`로 표시됩니다. 문자 유형은 숫자로 직접  사용할 수 없습니다.

 

```kotlin

fun check(c: Char) {

    if (c == 1) { // ERROR: incompatible types

        // ...
    }
}

```

 

문자 리터럴은 작은 따옴표로 나타냅니다. `'1'`

특수 문자는 백슬래시를 사용하여 이스케이프 처리할 수 있습니다.

다음 이스케이프 시퀀스가 ​​지원됩니다`\의 t`,`\의 b`,`n` \ '\의 r`,`\`,`\ "`,`\\`와`\ $`

''\ uFF00'` : 다른 문자를 인코딩하려면 유니 코드 이스케이프 시퀀스 구문을 사용하면 됩니다.

 

`Int`형은 명시적으로 숫자 변환을 할 수 있습니다 

 

```kotiln

fun decumalDigitValue(c: Char): Int {

    if (c !In '0'..'9')

        throw IllegalArgumentException("Out if range")

    return c.toInt() - '0'.toInt() //  Explicit conversions to numbers

}

```

 

숫자와 마찬가지로 , 문자도 nullable 참조가 필요하다면 감싸져 사용할 수 있습니다. 기존 타입은 감싸진 작업에 의해 보존되지는 않습니다.

 

## 부울

 

`Boolean` 타입은  논리 값을 나타내고, * 사실 * {: .keyword}과 * 거짓 * {: .keyword} 같은 두가지의 값이 있습니다.

 

Boolean타입 또한 nullable참조가 필요하다면 감싸져 사용 할 수 있습니다.

 

기계 번역
부울에 내장 작업은 다음과 같습니다
문자 개수: 19개
 

 

*`||`- 게으른 분리

*`&&`- 게으른 함께

p40.`- 부정

 

## 배열

 

코 틀린의 배열은 몇 가지 다른 유용한 멤버 함수와 함께`get`와`set` 기능 (`[]`운영자에 의해 오버로드 규칙에 턴)와`size` 속성을 가지고있는`Array` 클래스로 표현됩니다 :

 

```코 틀린

클래스 Array <T> 개인 생성자 () {

    발 크기 : 지능

    재미 GET (지수 : INT) : T

    재미 세트 (지수 : 지능, 값 : T) : 단위

 

    재미 반복자 () : 반복자 <T>

    p40.

p40.

p40.

 

배열을 생성하기 위해, 라이브러리 함수`arrayOf () '을 사용하고'arrayOf (1, 2, 3) '배열을 생성하도록, 그것을 항목 값을 전달할 [1, 2, 3].

대안 적으로,`arrayOfNulls ()`라이브러리 함수 null 요소 가득 주어진 크기의 어레이를 만드는 데 사용될 수있다.

 

또 다른 옵션은 초기 값을 리턴 할 수있는 어레이 크기 및 기능을 얻어 팩토리 함수를 사용하는

각 배열 요소의 인덱스를 부여 :

 

```코 틀린

// 값으로 배열 <문자열> 작성 [ "0", "1", "4", "9", "16"]

발 오름차순 = 배열 ​​(5, {내가 -> (내가)로 .toString () *})

p40.

 

위에서 말했듯이,은`[]`작업이 멤버 함수를 호출 약자`얻을 수 ()`와`설정 ()`.

 

참고 : 자바와는 달리, 코 틀린의 배열은 불변이다. 이는`코 틀린 우리는`배열 <문자열>을 할당 할 수 없음을 의미합니다

`배열에 <임의>`, 가능한 런타임 오류를 방지하는은 (하지만 당신은`배열 <아웃 상관 없음>`사용할 수 있습니다,

[유형 계획]을 참조 (generics.html # 형 돌기)).

 

`ByteArray` : 코 틀린는 권투 오버 헤드없이 원시 형의 배열을 표현하는 클래스를 전문

그래서`ShortArray`,`IntArray`합니다. 이러한 클래스는`Array` 클래스에 상속 관계가 없지만, 이들은

메서드 및 속성의 동일한 세트를 가지고있다. 그들 각각은 대응하는 공장 기능을 갖는다 :

 

```코 틀린

발은 X : IntArray intArrayOf = (1, 2, 3)

트

p40.

 

문자열(Strings)

 

문자열은 유형 'String`로 표시됩니다. 문자열은 불변입니다.

`s의 [I]`: 문자열의 요소는 인덱싱 작업으로 액세스 할 수있는 문자입니다.

{: .keyword} -loop 문자열은 *에 대한 *으로 이상 반복 할 수 있습니다 :

 

```코 틀린

용 (캐릭터에 다) {

    에 println (c)

p40.

p40.

 

### 문자열 리터럴

 

뉴 라인과 임의의 텍스트를 포함 할 수 있습니다 그들에 문자를 탈출 할 수 이스케이프 문자열과 원시 문자열 : 코 틀린 문자열 리터럴의 두 가지 유형이 있습니다. 이스케이프 문자열은 자바 문자열과 같은 아주 많이 있습니다 :

 

```코 틀린

발의 = "안녕하세요, 세계!\엔"

p40.

 

이스케이프는 백 슬래시로, 종래의 방법으로 이루어집니다. 지원되는 이스케이프 시퀀스 목록은 위의 [문자 (# 문자)를 참조하십시오.

 

원시 문자열은 삼중 따옴표 (` "" "`), 더 이스케이프를 포함하지 않고 줄 바꿈 및 기타 문자를 포함 할 수 있습니다으로 구분된다 :

 

```코 틀린

발 텍스트 = "" "

    ( "foo는"에 C)에 대한

        토너 (C)

"" "

p40.

 

당신은 [`trimMargin ()`(https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html) 함수 선행 공백을 제거 할 수 있습니다 :

 

```코 틀린

발 텍스트 = "" "

    | 말해 내가 잊어 버려.

    | 가르쳐 나는 기억한다.

    | 나를 참여와 내가 알아.

    벤자민 프랭클린 (Benjamin Franklin) 2

    "" ".trimMargin ()

p40.

 

기본적으로`|`마진 접두사로 사용됩니다,하지만 당신은`trimMargin ( ">")`과 같은 다른 문자를 선택하고 매개 변수로 전달할 수 있습니다.

 

### 문자열 템플릿

 

문자열은 그 결과를 문자열로 연결됩니다 템플릿 식, 평가 코드, 즉 조각을 포함 할 수 있습니다.

템플릿 표현식은 달러 기호 ($)로 시작하거나 간단한 이름으로 구성됩니다 :

 

```코 틀린

발 전 (10) =

발들 = "나는 $ 내가 ="//이 "전 = 10"평가

p40.

 

중괄호 또는 임의의 표현 :

 

```코 틀린

발의 = "ABC"

발 STR = "$의 s.length가 $ {s.length}이다"//이에 "abc.length가 3"평가

p40.

 

템플릿은 원시 문자열 내부에 내부 이스케이프 문자열 모두 지원됩니다.

당신은 원시 문자열 리터럴`$ '문자 (백 슬래시 이스케이프 지원하지 않는) 표현해야하는 경우, 다음과 같은 구문을 사용할 수 있습니다 :

 

```코 틀린

발 가격 = "" "

p40.

"" "

p40.