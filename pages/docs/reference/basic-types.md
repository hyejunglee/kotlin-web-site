---

유형 : 문서

레이아웃 : 참조

카테고리 : "구문"

제목 : "기본 유형"

---

 

# 기본 유형

 

코틀린에서는  모든것이 오브젝트의 의미이고,  당신은 어느 변수에서건 멤버 함수와 속성을 호출 할 수 있습니다 . 구현이 최적화되어 있기 때문에 일부 유형에 내장되어 있지만, 사용자들은 보통 클래스처럼 생각하면 됩니다. 이 섹션에서 우리는 숫자, 문자, 부울 및 배열 등의 유형을 설명합니다.

 

숫자.

 

코틀린 자바와 비슷한 방식으로 숫자를 처리하지만, 정확히 같지는 않습니다. 예를 들어, 숫자들에 대한 함축적인 확대 변환은없고, 리터럴은 경우에 따라 약간 다릅니다.

 

코틀린은 숫자를 나타내는데 다음과 같은 기본 유형을 제공합니다 (자바에 가까운):

 

| 입력 | bit width |

 Double  : 64 

 Float   : 32 

 Long 	 : 64

 int	 : 32 

 Short	 : 16 

 Byte	 : 8 

 

위 표의 형식들은 코틀린에서는 숫자들이 아닙니다.

 

### 리터럴 상수

 

리터럴 상수의 구성요소에는 다음과 같은 종류가 있습니다.

 

* 소수 :`123`

* Long형의 문자 끝에 `L` 을 붙이면 됩니다. : `123L`

* 16진법 :  `0x0F`

* 바이너리 :    `0b00001011`

 

참고 : 8진법 리터럴은 지원되지 않습니다.

 

코틀린는 부동 소수점 숫자에 대한 기존의 표기법을 지원합니다 :

 

* 기본적인 Double 형 :`123.5`,`123.5e10`

* Float형의  문자 끝에 `f` 또는 F` 를 붙이면 됩니다.  : `123.5f`

 

### 표현

 

우리가 nullable 숫자나, 제너릭을 포함시키지 않는다면 , 자바 플랫폼에서는 실제로 숫자들이 JVM 기본형식으로 저장됩니다.

후자의 경우 숫자들을 기본type 을 객체로 썼다.

 

기본type의 숫자들은 동일하게 유지되지 않습니다.

 

```kotlin

val a: Int = 10000

print (a === a) // print `true` 값을 비교할 때 '=='과 '==='으로 비교할 수 있습니다.

val boxedA: Int? = a val anotherBoxedA: Int? = a

print (boxedA === anotherBoxedA) // !!! print `false` !!!

print(boxedA === anotherBoxedA) //! prints `false` !!!!

```

 

한편으로 같게 유지된다.

 

```kotiln

val a: Int  =  10000

print ( a == a ) // prints `true`

val boxedA: Int? =a

val anotherBoxedA: Int? = a

print(boxedA == anotherBoxedA) // prints `true`

```

 

### 명시적 형 변환

 

다른 표현 때문에 , 작은 유형은 큰 사람의 아형 수 없습니다.

그들이 있다면, 우리는 다음과 같은 종류의 문제있을 것입니다 :

 

```kotlin

// 가설 코드가 실제로 컴파일되지 않습니다 :

발 A : 지능? = 1 // 박스형 지능 (java.lang의.Integer

발에 B : 긴? = A // 암시 적 변환은 박스형 롱 (java.lang의를 얻을 수 있습니다.길게

인쇄의 (a == 나) // 깜짝! 이 롱의 등호로 "false"를 인쇄 () 긴뿐만 아니라 할 다른 부분을 확인

```

 

그래서 정체성 그러나 심지어 평등뿐만 도처에 자동으로 상실되었을 것입니다.

 

결과적으로, 작은 유형은 암시 적으로 더 큰 유형으로 변환되지 않습니다.

이것은 우리가 명시 적으로 전환하지 않고 'Int` 변수 Byte`'형식의 값을 할당 할 수 있다는 것을 의미

 

```코 틀린

발에 B : 바이트 = 1 // OK, 리터럴은 정적으로 체크

발 전 : 지능 = B // ERROR

p40.

 

우리는 숫자를 확대하기 위해 명시 적 변환을 사용할 수 있습니다

 

```코 틀린

발 전 : 지능 = b.toInt () // OK : 명시 적으로 확대

p40.

 

모든 숫자 유형은 다음의 변환을 지원합니다 :

 

*`toByte () : Byte`

*`toShort () : Short`

*`toInt () : Int`

*`toLong () : Long`

*`toFloat () : Float`

*`toDouble () : Double`

*`toChar () : Char`

 

암시 적 변환의 유무 형태는 문맥에서 유추 때문에 거의 두드러 및 산술 연산은 예를 들어, 적절한 전환을 위해 과부하

 

```코 틀린

발 리터 = 1L + 3 // 긴 + 지능 => 롱

p40.

 

(1) 영업

 

코 틀린는 해당 클래스의 구성원으로 선언 된 번호를 통해 산술 연산의 표준 집합을 지원합니다 (그러나 컴파일러는 해당 지침에 이르기까지 호출을 최적화).

[연산자 오버로딩 (운영자 overloading.html)를 참조하십시오.

 

비트 연산으로, 더 그들을 위해 특수 문자하지만, 예를 들어 중위 형태로 호출 할 수있는 단지라는 기능을, 거기 없다 :

 

```코 틀린

발 X = (1 SHL 2) 0x000FF000

p40.

 

여기에 (Int`와`Long``에만 사용 가능) 비트 연산의 전체 목록은 다음과 같습니다

 

*`SHL (비트)`- 시프트 왼쪽 서명 (자바의`<<`)

*`SHR (비트)`- 서명 오른쪽 쉬프트 (자바의`>>`)

*`ushr (비트)`- 부호 오른쪽 쉬프트 (자바의`>>>`)

* '와 (비트)`- 비트 및

* '또는 (비트)`- 비트 또는

*`XOR (비트)`- 비트 XOR

*`의 INV ()`- 비트 반전

 

등장 인물

 

문자는 유형 'Char`로 표시됩니다. 그들은 숫자로 직접 처리 할 수 ​​없습니다

 

```코 틀린

재미 검사 (C : 샤아) {

    경우 (다 == 1) {// 오류 : 호환되지 않는 유형

        p40.

    p40.

p40.

p40.

 

문자 리터럴은 작은 따옴표로 이동합니다`1'`.

특수 문자는 백 슬래시를 사용하여 이스케이프 할 수 있습니다.

다음 이스케이프 시퀀스가 ​​지원됩니다`\의 t`,`\의 b`,`n` \ '\의 r`,`\`,`\ "`,`\\`와`\ $으로`.

''\ uFF00'` : 다른 문자를 인코딩하려면 유니 코드 이스케이프 시퀀스 구문을 사용합니다.

 

우리는 명시 적으로`Int` 번호로 문자를 변환 할 수 있습니다 :

 

```코 틀린

재미 decimalDigitValue (C : 샤아) : 지능 {

    (다 경우에!입고p40.

        는 IllegalArgumentException ( "범위 중")를 던져

    숫자 '0'.toInt () // 명시 적 변환 - c.toInt ()를 호출

p40.

p40.

 

null 허용 기준이 필요할 때 숫자처럼, 문자 박스 있습니다. ID는 권투 동작에 의해 유지되지 않습니다.

 

## 부울

 

유형은`Boolean` 논리 값을 나타내고, 두 값이있다 : * 사실 * {: .keyword}과 * 거짓 * {: .keyword}.

 

null 허용 기준이 필요한 경우 부울는 박스 있습니다.

 

부울에 내장 작업은 다음과 같습니다

 

*`||`- 게으른 분리

*`&&`- 게으른 함께

p40.`- 부정

 

## 배열

 

코 틀린의 배열은 몇 가지 다른 유용한 멤버 함수와 함께`get`와`set` 기능 (`[]`운영자에 의해 오버로드 규칙에 턴)와`size` 속성을 가지고있는`Array` 클래스로 표현됩니다 :

 

```코 틀린

클래스 Array <T> 개인 생성자 () {

    발 크기 : 지능

    재미 GET (지수 : INT) : T

    재미 세트 (지수 : 지능, 값 : T) : 단위

 

    재미 반복자 () : 반복자 <T>

    p40.

p40.

p40.

 

배열을 생성하기 위해, 라이브러리 함수`arrayOf () '을 사용하고'arrayOf (1, 2, 3) '배열을 생성하도록, 그것을 항목 값을 전달할 [1, 2, 3].

대안 적으로,`arrayOfNulls ()`라이브러리 함수 null 요소 가득 주어진 크기의 어레이를 만드는 데 사용될 수있다.

 

또 다른 옵션은 초기 값을 리턴 할 수있는 어레이 크기 및 기능을 얻어 팩토리 함수를 사용하는

각 배열 요소의 인덱스를 부여 :

 

```코 틀린

// 값으로 배열 <문자열> 작성 [ "0", "1", "4", "9", "16"]

발 오름차순 = 배열 ​​(5, {내가 -> (내가)로 .toString () *})

p40.

 

위에서 말했듯이,은`[]`작업이 멤버 함수를 호출 약자`얻을 수 ()`와`설정 ()`.

 

참고 : 자바와는 달리, 코 틀린의 배열은 불변이다. 이는`코 틀린 우리는`배열 <문자열>을 할당 할 수 없음을 의미합니다

`배열에 <임의>`, 가능한 런타임 오류를 방지하는은 (하지만 당신은`배열 <아웃 상관 없음>`사용할 수 있습니다,

[유형 계획]을 참조 (generics.html # 형 돌기)).

 

`ByteArray` : 코 틀린는 권투 오버 헤드없이 원시 형의 배열을 표현하는 클래스를 전문

그래서`ShortArray`,`IntArray`합니다. 이러한 클래스는`Array` 클래스에 상속 관계가 없지만, 이들은

메서드 및 속성의 동일한 세트를 가지고있다. 그들 각각은 대응하는 공장 기능을 갖는다 :

 

```코 틀린

발은 X : IntArray intArrayOf = (1, 2, 3)

트

p40.

 

문자열(Strings)

 

문자열은 유형 'String`로 표시됩니다. 문자열은 불변입니다.

`s의 [I]`: 문자열의 요소는 인덱싱 작업으로 액세스 할 수있는 문자입니다.

{: .keyword} -loop 문자열은 *에 대한 *으로 이상 반복 할 수 있습니다 :

 

```코 틀린

용 (캐릭터에 다) {

    에 println (c)

p40.

p40.

 

### 문자열 리터럴

 

뉴 라인과 임의의 텍스트를 포함 할 수 있습니다 그들에 문자를 탈출 할 수 이스케이프 문자열과 원시 문자열 : 코 틀린 문자열 리터럴의 두 가지 유형이 있습니다. 이스케이프 문자열은 자바 문자열과 같은 아주 많이 있습니다 :

 

```코 틀린

발의 = "안녕하세요, 세계!\엔"

p40.

 

이스케이프는 백 슬래시로, 종래의 방법으로 이루어집니다. 지원되는 이스케이프 시퀀스 목록은 위의 [문자 (# 문자)를 참조하십시오.

 

원시 문자열은 삼중 따옴표 (` "" "`), 더 이스케이프를 포함하지 않고 줄 바꿈 및 기타 문자를 포함 할 수 있습니다으로 구분된다 :

 

```코 틀린

발 텍스트 = "" "

    ( "foo는"에 C)에 대한

        토너 (C)

"" "

p40.

 

당신은 [`trimMargin ()`(https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html) 함수 선행 공백을 제거 할 수 있습니다 :

 

```코 틀린

발 텍스트 = "" "

    | 말해 내가 잊어 버려.

    | 가르쳐 나는 기억한다.

    | 나를 참여와 내가 알아.

    벤자민 프랭클린 (Benjamin Franklin) 2

    "" ".trimMargin ()

p40.

 

기본적으로`|`마진 접두사로 사용됩니다,하지만 당신은`trimMargin ( ">")`과 같은 다른 문자를 선택하고 매개 변수로 전달할 수 있습니다.

 

### 문자열 템플릿

 

문자열은 그 결과를 문자열로 연결됩니다 템플릿 식, 평가 코드, 즉 조각을 포함 할 수 있습니다.

템플릿 표현식은 달러 기호 ($)로 시작하거나 간단한 이름으로 구성됩니다 :

 

```코 틀린

발 전 (10) =

발들 = "나는 $ 내가 ="//이 "전 = 10"평가

p40.

 

중괄호 또는 임의의 표현 :

 

```코 틀린

발의 = "ABC"

발 STR = "$의 s.length가 $ {s.length}이다"//이에 "abc.length가 3"평가

p40.

 

템플릿은 원시 문자열 내부에 내부 이스케이프 문자열 모두 지원됩니다.

당신은 원시 문자열 리터럴`$ '문자 (백 슬래시 이스케이프 지원하지 않는) 표현해야하는 경우, 다음과 같은 구문을 사용할 수 있습니다 :

 

```코 틀린

발 가격 = "" "

p40.

"" "

p40.